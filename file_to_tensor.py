#!/opt/homebrew/bin/python3
import torch

# from torch.utils.data import DataLoader, TensorDataset
from pathlib import Path
from opseqtoindex import opseq_to_index
import os
import tqdm

MAX_LENGTH = 1 << 15

# def calcMaxLength() -> int:
#     maxLength = 0
#     bfiles = Path("./Malign").glob('*.opseq')
#     for f in bfiles:
#         indices_list = open_opseq(f)
#         #print("\n\nnew list\n\n")
#         #print(os.path.basename(f))
#         #print("\n\n")
#         #print(indices_list)
#         #print("\n\n")
#         #print(len(indices_list))
#         if (maxLength < len(indices_list)):
#             maxLength = len(indices_list)
#             file_name = os.path.basename(f)
#         #print("\n\nmaxLength\n\n")
#         #print(maxLength)
#         #print("\n\ncurrent length\n\n")
#         #print(len(indices_list))


# mfiles = Path("./Benign").glob('*.opseq')
# for f in mfiles:
#     indices_list = open_opseq(f)
#     #print("\n\nnew list\n\n")
#     #print(os.path.basename(f))
#     #print("\n\n")
#     #print(indices_list)
#     #print("\n\n")
#     #print(len(indices_list))
#     if (maxLength < len(indices_list)):
#         maxLength = len(indices_list)
#         file_name = os.path.basename(f)
#     #print("\n\nmaxLength\n\n")
#     #print(maxLength)
#     #print("\n\ncurrent length\n\n")
#     #print(len(indices_list))
# #print("\n\nMAAAAX LENGTH\n\n")
# #print(maxLength)
# return maxLength, file_name

# class opseqLabels:
#    def __init__(self, opseq: list[int], label: int):
#        self.opseq = opseq
#        self.label = label


def processOpseqLabels(opcode_sequences: list[list], labels: list[int]):
    # Convert data to tensors
    # opcode_sequences = [torch.tensor(seq) for seq in opcode_sequences]
    tensor_of_tensors_opcode_sequences = torch.stack([torch.tensor(seq) for seq in opcode_sequences])
    labels = torch.tensor(labels)
    """
    print("\n\nTENSORS\n\n")
    print(tensor_of_tensors_opcode_sequences)
    print("\n\n")
    print(labels)
    print(tensor_of_tensors_opcode_sequences.size())
    print(labels.size())
    """
    return tensor_of_tensors_opcode_sequences, labels


# def printListOpseqLabels(opseq: list[list], labels: list[int]):

#     print("\n\nlen opseq\n\n")
#     print(len(opseq))
#     print("\n\n")
#     print("\n\nlen labels\n\n")
#     print(len(labels))
#     print("\n\n")

#     for i in range(len(opseq)):
#         print(opseq[i])
#         print("\n\nlen opseq[i]\n\n")
#         print(len(opseq[i]))
#         print(labels[i])

#     #result = calcMaxLength()
#     #maxLength = result[0]
#     #print("\n\nMAAAAX LENGTH\n\n")
#     #print(maxLength)
#     #print("\n\nfile name \n\n")
#     #print(result[1])


def read_files() -> list[int]:
    opcode_sequences = []
    labels = []
    # result = calcMaxLength()
    files = tuple(Path("./Malign").glob("*.opseq"))
    for f in tqdm.tqdm(files):
        indices_list = open_opseq(f)
        # assert 218 in indices_list
        while len(indices_list) < MAX_LENGTH:
            indices_list.append(219)
        if len(indices_list) > MAX_LENGTH:
            indices_list = indices_list[:MAX_LENGTH]
        opcode_sequences.append(indices_list)
        labels.append(1)
        # data = opseqLabels(indices_list, 0)
        # opseq_labels.append(data)

    filesMalware = tuple(Path("./Benign").glob("*.opseq"))

    for f in tqdm.tqdm(filesMalware):
        indices_list = open_opseq(f)
        # assert 218 in indices_list
        while len(indices_list) < MAX_LENGTH:
            indices_list.append(219)
        if len(indices_list) > MAX_LENGTH:
            indices_list = indices_list[:MAX_LENGTH]
        opcode_sequences.append(indices_list)
        labels.append(0)
        # data = opseqLabels(indices_list, 1)
        # opseq_labels.append(data)

    return opcode_sequences, labels


# def _test():
#     opseq_path = Path("short.opseq")
#     indices_list = open_opseq(opseq_path)

#     print(indices_list)
#     print("\n\nlen\n\n")
#     print(len(indices_list))


def open_opseq(opseq_path: Path) -> list[int]:
    """
    :returns: list of indices of opcodes
    """
    with open(opseq_path) as file:
        lines = file.readlines()
    indices_list = []
    for line in lines:
        chunks = [line[i : i + 2] for i in range(0, len(line), 2)]
        indices_list += opseq_to_index(chunks)
    return indices_list


if __name__ == "__main__":
    # calcMaxLength()
    # _test()
    opcode_sequences, labels = read_files()
    # printListOpseqLabels(opcode_sequences, labels)
    tensor_of_tensors_opcode_sequences, labels = processOpseqLabels(opcode_sequences, labels)

    save_path = Path("data")
    if not save_path.exists():
        save_path.mkdir(exist_ok=True, parents=True)
    torch.save(tensor_of_tensors_opcode_sequences, save_path / f"opcode_sequences_{MAX_LENGTH}.pt")
    torch.save(labels, save_path / f"labels_{MAX_LENGTH}.pt")
